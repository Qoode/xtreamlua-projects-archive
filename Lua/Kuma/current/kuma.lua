


meta = {"name","desc","author","current","current_class","current_namespace","type","arg","ret"}
class = {}


HEADER = 	[===[
				<html>
					<head>
						<title>%s</title>
						<link rel="stylesheet" type="text/css" href="docstyle.css">
						<script type="text/javascript">
							var current = "start";
							function setContent(name){
								document.getElementById(current).style.display = "none";	
								document.getElementById(name).style.display = "inline";
								current = name;
							}
						</script>
					</head>
					<body>
						<table id="main">
							<tr>
			]===]
			
FOOTER =  	[===[
									<div id="start"><div class="title">Index</div>%s</div>
								</td>
							</tr>
						</table>
						<div id="footer">
							This document was generated by <a href="http://shaolan.net/?page_id=29">Kuma</a> - written by Shaolan
						</div>
					</body>
				</html>
			]===]
			
DEFAULT_INDEX = [===[
					Bienvenue sur la page d'accueil de cette documentation.
				]===]	
			
template = {}
			
template.file = [===[
					<div class="title">Fichier : %s</div>
					<div class="desc">%s</div>
					<table class="author"><tr><td>%s</td></tr></table><br />
					<div class="list">%s</div>
				]===]

template.author = [===[
						Auteur&nbsp;:&nbsp;%s<br/>
						E-mail&nbsp;:&nbsp;<a href="mailto:%s">%s</a><br/>
						Site&nbsp;web&nbsp;:&nbsp;<a href="%s">%s</a><br/>
				  ]===]
					 
template.func = 	[===[
						<div class="title"><span class="func">function</span> %s</div><br />
						<div class="desc">%s</div>
						<div class="title">Arguments :</div><br />
						<div style="padding-left: 20px;">%s</div><br />
						<div class="title">Valeur de retour :</div><br />
						<div style="padding-left: 20px;">%s</div>
					]===]
					
template.method = 	[===[
						<div class="title"><span class="class">%s</span>:<span class="func">%s</span></div><br />
						<div class="desc">%s</div>
						<div class="title">Arguments :</div><br />
						<div style="padding-left: 20px;">
							<span class="type">Object</span> this -> pointeur sur objet<br />
							%s
						</div><br />
						<div class="title">Valeur de retour :</div><br />
						<div style="padding-left: 20px;">%s</div>
					]===]
					
template.class = 	[===[
						<div class="title"><span class="class">class</span> %s</div><br />
						<div class="desc">%s</div><br />
						<div class="title">Arguments :</div><br />
						<div style="padding-left: 20px;">%s</div><br />
						<div class="title">Attributs :</div><br />
						<div style="padding-left: 20px;">%s</div><br />
						<div class="title">Méthodes :</div><br />
						<div style="padding-left: 20px;">%s</div><br />
					]===]

					
					
template.arg = [===[ <span class="type">%s</span> %s - %s<br />]===]
template.ret = [===[ <span class="type">%s</span> - %s <br />]===]
template.var = [===[ <span class="type">%s</span> %s - %s <br/>]===]
template.const = [===[ <b>const</b> <span class="type">%s</span> %s - %s<br />]===]

--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
-- Tools definition
--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
function string.split(self,c)
        local s,t,c = 0,{},c or " "
        for p=0,self:len() do
                if self:sub(p,p) == c then
                        table.insert(t,self:sub(s,p-1))
                        s = p+1
                end
        end
        table.insert(t,self:sub(s))
        return t
end

function notIn(k,t)
	for i,v in ipairs(t) do
		if k == v then return false end
	end
	return true
end

function isClass(name)
	for i,classname in ipairs(class) do
		if classname == name then return true end
	end
	return false
end

function getFrom(ptr,key,required)
	local t,n = {}, 0
	for k,v in pairs(ptr) do if v[key] and v[key] == required then t[k] ,n = v, n + 1 end end
	return t,n
end

function get(t,key)
	local n = {}
	for i,v in pairs(t) do if v[key] and notIn(v[key],n) then table.insert(n,v[key]) end end
	return n
end

--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
-- Maker definition
--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
local m = {}
local f = string.format

function m.file(ptr) return f(template.file,ptr.name or "",ptr.desc or "",m.author(ptr.author),m.list(ptr)) end
function m.author(ptr) return f(template.author,ptr.name or "",ptr.email or "",ptr.email or "",ptr.website or "",ptr.website or "") end
function m.arg(ptr,class) if not(ptr) then return (class ~= nil and "") or "----" end local s = "" for i,arg in ipairs(ptr) do s = s..f(template.arg,(isClass(arg.type) and m.class_link(arg.type)) or arg.type or "",arg.name or "",arg.desc or "") end return s end
function m.ret(ptr) if not(ptr) then return "----" end local s = "" for i,ret in ipairs(ptr) do s = s..f(template.ret,(isClass(ret.type) and m.class_link(ret.type)) or ret.type or "",ret.desc or "") end return s end
function m.func(ptr,name) return f(template.func,name or "",ptr.desc or "",m.arg(ptr.arg),m.ret(ptr.ret)) end
function m.var(ptr,name) return f(template.var,(isClass(ptr.type_var) and m.class_link(ptr.type_var)) or ptr.type_var or "",name or "",ptr.desc or "") end
function m.const(ptr,name) return f(template.const,(isClass(ptr.type_const) and m.class_link(ptr.type_const)) or ptr.type_class or "",name or "",ptr.desc or "") end
function m.class(ptr,name) return f(template.class,name or "",ptr.desc or "",m.arg(ptr.arg),m.attributeList(ptr),m.methodList(ptr,name)) end
function m.method(class,name,ptr) return f(template.method,m.class_link(class),name or "",ptr.desc or "",m.arg(ptr.arg,class),m.ret(ptr.ret)) end
function m.attribute(ptr,name) return f(template.var,(isClass(ptr.type) and m.class_link(ptr.type)) or ptr.type or "",name or "",ptr.desc or "") end
function m.link(name,t) return f("<span class=\""..t.."\">"..t.."</span>&nbsp;<a href=\"javascript:setContent('%s')\">%s</a><br />",name or "",name or "") end
function m.class_link(name) return f("<a href=\"javascript:setContent('%s')\" class=\"class_link\">%s</a>",name or "",name or "") end
function m.method_link(class,name) return f("<a href=\"javascript:setContent('%s_%s')\" class=\"method_link\">%s</a><br />",class or "",name or "",name or "") end

function m.list(ptr) 
	local s = ""
	for _,typename in ipairs({"class","func"}) do
		local t , n = getFrom(ptr,"type",typename)
		if n ~= 0 then 
			s = s.."<div class=\"title\">"..typename.."(s) :</div><br /><div style=\"padding-left:20px;\">" 
			for name,data in pairs(t) do if notIn(name,meta) then s = s..m.link(name,data.type) end end
			s = s.."</div>"
		end
	end
	for _,typename in ipairs({"var","const"}) do
		local t , n = getFrom(ptr,"type",typename)
		if n ~= 0 then 
			s = s.."<br /><div class=\"title\">"..typename.."(s) :</div><br /><div style=\"padding-left:20px;\">"
			namespace = get(t,"namespace")
			for name,data in pairs(t) do if notIn(name,meta) and not(data.namespace) then s = s..m.var(data,name) end end
			for _,n in ipairs(namespace) do
				local tn = getFrom(t,"namespace",n)
				s = s.."<br /><div class=\"title\">"..n.." :</div><br /><div style=\"padding-left:20px;\">"
				for name,data in pairs(tn) do if notIn(name,meta) then s = s..m[data.type](data,name) end end
				s = s.."</div>"
			end
			s = s.."</div>"
		end
	end
	return s
end

function m.attributeList(ptr)
	local s = ""
	for name,data in pairs(ptr) do if notIn(name,meta) and not(data.type == "method") then s = s..m.attribute(data,name) end end
	return s
end

function m.methodList(ptr,name)
	local s = ""
	for n,data in pairs(ptr) do if notIn(name,meta) and data.type == "method" then s = s..m.method_link(name,n) end end
	return s
end

--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
-- Parser definition
--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
local p = {}

function parse(model,entity)
	local t = {}
	for i=1,#model-1 do t[model[i]] = table.remove(entity,1) end
	t[model[#model]] = table.concat(entity," ")
	return t
end

function p.file(ptr,data) 
	ptr.name = table.remove(data,1) 
	ptr.desc = table.concat(data," ") 
end
function p.author(ptr,data) ptr.author = parse({"name","email","website"},data) end

function p.func(ptr,data)
	local name = table.remove(data,1)
	ptr[name] = { type = "func", desc = table.concat(data," ") }
	ptr.current = ptr[name]
end

function p.arg(ptr,data)
	if not(ptr.current.arg) then ptr.current.arg = {} end
	local t = parse({"type","name","desc"},data)
	table.insert(ptr.current.arg,t)
end

function p.ret(ptr,data)
	if not(ptr.current.ret) then ptr.current.ret = {} end
	local t = parse({"type","desc"},data)
	table.insert(ptr.current.ret,t)
end

function p.class(ptr,data)
	local name = table.remove(data,1)
	ptr[name] = { type = "class", desc = table.concat(data," ") }
	ptr.current = ptr[name]
	ptr.current_class = name
	table.insert(class,name)
end

function p.method(ptr,data)
	local name = table.remove(data,1)
	ptr[ptr.current_class][name] = { type = "method", desc = table.concat(data," ") }
	ptr.current = ptr[ptr.current_class][name]
end

function p.attribute(ptr,data)
	local name = table.remove(data,1)
	ptr.current[name] = parse({"type","desc"},data)
end

function p.var(ptr,data)
	local name = table.remove(data,1)
	ptr[name] = parse({"type_var","desc"},data)
	ptr[name].type = "var"
	ptr[name].namespace = ptr.current_namespace
end

function p.const(ptr,data)
	local name = table.remove(data,1)
	ptr[name] = parse({"type_const","desc"},data)
	ptr[name].type = "const"
	ptr[name].namespace = ptr.current_namespace
end

function p.namespace(ptr,data)
	ptr.current_namespace = table.remove(data,1)
end

function p.namespace_end(ptr,data)
	ptr.current_namespace = nil
end

--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
-- Generator definition
--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
g = {}

function g.parseFile(path)	
	local stdin = io.open(path,"r")
	if not(stdin) then
		print("Error : cannot open "..path)
		return nil
	end
	local tree = {}
	for l in stdin:lines() do
		if l:find("--%% ") then
			local i = l:find("--%% ") 
			local name = l:match("--%% ([a-z]+)")
			local buffer = l:sub(i):split()
			table.remove(buffer,1)
			table.remove(buffer,1)
			if p[name] then p[name](tree,buffer) end
		end
	end
	return tree
end

function g.getFileTree(filelist,root)
	local t = {}
	for key,value in pairs(filelist) do
		if type(value) == "table" then 
			t[key] = g.getFileTree(value,root..key.."/")
			t[key].type = "dir"
		else 
			local f = g.parseFile(root..value) 
			if not(f) then return nil end
			t[key] = f
		end
	end
	return t
end

function g.getContentLayer(stdout,tree)
	for name,ptr in pairs(tree) do
		if ptr.type and ptr.type == "dir" then g.getContentLayer(stdout,ptr)
		elseif type(ptr) == "table" then 
			stdout:write("<div id=\""..ptr.name.."\" style=\"display:none;\">")
			stdout:write(m.file(ptr))
			stdout:write("</div>")
			g.getEntity(stdout,ptr)
		end
	end
end

function g.getEntity(stdout,ptr)
	for k,v in pairs(ptr) do
		if notIn(k,meta) then
			if v.type == "class" then
				stdout:write("<div id=\""..k.."\" style=\"display:none;\">")
				stdout:write(m[v.type](v,k))
				stdout:write("</div>")
				for name,element in pairs(v) do
					if element.type and element.type == "method" then
						stdout:write("<div id=\""..k.."_"..name.."\" style=\"display:none;\">")
						stdout:write(m.method(k,name,element))
						stdout:write("</div>")
					end
				end
			else
				stdout:write("<div id=\""..k.."\" style=\"display:none;\">")
				stdout:write(m[v.type](v,k))
				stdout:write("</div>")
			end
		end
	end
end

function g.getMenu(stdout,tree)	
	for name,ptr in pairs(tree) do
		if ptr.type and ptr.type == "dir" then
			stdout:write("<tr><td>"..name.."/<br /><table style=\"padding-left:20px;\">")
			g.getMenu(stdout,ptr)
			stdout:write("</table></td></tr>")
		elseif type(ptr) == "table" then
			local s = "<tr><td><a class=\"menu\" href=\"javascript:setContent('"..ptr.name.."')\">"..ptr.name.."</a></td></tr>"
			stdout:write(s)
		end
	end
end

function g.HTMLDocument(filelist,name_out,title)
	local tree = g.getFileTree(filelist,"./")
	if not(tree) then return nil end
	local stdout = io.open(name_out or "doc.html","w")
	stdout:write(f(HEADER,title or "Kuma Documentation")) 
	-- Write menu
	stdout:write("\t\t<td id=\"menu\"><table>\n")
	g.getMenu(stdout,tree)
	stdout:write("\t\t</table></td>")
	-- Write content
	stdout:write("\t\t<td id=\"content\">\n")
	g.getContentLayer(stdout,tree)
	stdout:write(f(FOOTER,index or DEFAULT_INDEX))
	stdout:close()
end

if arg[1] then
	dofile(arg[1])
	if filelist then
		g.HTMLDocument(filelist,arg[2],arg[3])
	else
		print("Error : missing file list into config file")
	end
else
	print("Usage : kuma config_file [output_file] [doc_title]")
end